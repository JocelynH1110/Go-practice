// 5-1 前言
/*
函式是許多程式語言的關鍵核心。
其實就是我們宣告來從事一項任務的一段程式碼。
Go 語言是可以完全沒有輸入和輸出、也可以有多重輸入和輸出。
Go 的函式和其他程式語言的不同處之一，就在於有能力回傳多重值。大多數程式語言都只能回傳一個值。

下面各節會看到 Go 語言一些與眾不同，適用於以下不同場合：
1.將函式當成引數傳遞給其他函式。
2.將函式賦值給變數、以及當成另一個函式的傳回值。
3.將函式視為型別。
4.匿名（anonymous）、閉包（closures）函式。

Go 語言是所謂的一級函式（first-class functions），就是函式可以當成其他函式的引數（傳給參數的值）或傳回值。
可以接收其他函式為引數的函式，又稱為高階函式（higher-order functions）。

// 5-2 函式
/*
使用函式的好理由：
1.分解複雜的任務：
程式就是要拿來執行任務的，若任務本身很複雜，應將其分解成多個較小的任務。函式可以應付各個小任務，藉以解決更大的問題。此外小任務較容易撰寫，且讓不同的函式來完成不同任務，能讓整體程式更易於維護。

2.精簡程式碼：
當發現程式中有一再重複出現的類似程式碼時，就表示應該把那些程式碼放進函式。重複的程式碼不易維護。

3.重複使用性：
一旦定義了函式，就可以一再呼叫它，甚至可被其他程式開發人員使用。這種函式可共享的特性，能讓你減少程式碼行數和省下時間，不必再重頭來過。


設計函式應當遵循的守則：
1.單一責任制：
一個函式應該只負責一項任務。這樣測試比較簡單也易維護。

2.短小精悍：
盡量讓函是的程式碼保持在 25 行以內。但也不是什麼鐵則。但簡潔的好處，是你可以避免替大型函式除錯時面臨的複雜性，撰寫單元測試時也能得到更好的程式碼覆蓋率（code coverage，被測試的原始碼比例）

// 5-2-1 函式的宣告和組成

/*
＊＊Go 語言函式典型的結構：
func add(i,j int)int{

}

以下為結構的解說：
1.函式宣告：
關鍵字 func。可以在套件層級（package）的任何位置使用 func 定義函式。

2.函式識別名稱（identifier）：
即函式名稱，ex. add。駝峰式（camelCase）命名，首字小寫，其後每個單字都大寫開頭。名稱要能望文生義，一看便知函式的用意。但也可以沒有名稱，也就是所謂的匿名函式。

NOTE、函式名稱首字母小寫，代表該函式不能被匯出到套件範圍之外，亦即該函式是套件的私有成員。無法從套件外部呼叫它。若想匯出到套件外，名稱字首需要大寫。（lesson 8）

3.參數清單（parameters）：
是函式的輸入值，ex.(i,j int)。是函式執行任務時所需的資料，為函式之內的區域變數。
一個函式可以完全不用參數，也可以有多重參數。
當多個參數型別一致時，可以用參數簡寫法，將每個參數後面重複的型別去掉。ex、(i int,j int) → (i,j int)。

＊＊參數在函式定義的格式如下：
<名稱1> <型別1>, <名稱2> <型別2>...

4.傳回型別：
是一系列資料型別，諸如布林值、字串、 map 或另一個函式都可以被函式傳回。
以宣告函式的角度來說，將這些型別稱為傳回型別。在呼叫函式時，他們稱作傳回值。
傳回值是函式的輸出，通常是拿引數運算後的結果。
傳回值和參數一樣可以不必寫（沒有傳回值）。
大多數程式語言的函式只能傳回單一值，但 Go 語言函式可一口氣傳回多個值。

5.函式特徵（signature）：
它是一個術語，是函式「輸入參數」和「輸出型別」的合稱。
當定義了個要被其他使用者運用的函式時，必須盡量避免更改函式特徵（等於是函式的呼叫與傳回值規格），以免在程式上線後對自己和別人的程式造成影響。

6.函式本體：
指包括在一對大括號{}之間的程式碼，這些程式碼決定了函式會做什麼事。

若函式有定義傳回型別，函式本體就必須有 return 敘述（函式中可以有不只一個 return 敘述）。
return 敘述會令函式立刻停止、並傳回列在 return 後面的一串值。這一串值的型別必須與宣告時的傳回型別清單一致。

Go 語言還有一個異於其他程式語言之處，就是左大括號 { 必須跟函式定義位於同一行（不換行）。否則編譯時會出現錯誤。
諸如 C 之類的語言中，會使用分號 ; 來對編譯器標示各指令的結束，但這寫法對使用者並不友善。
Go 語言為了去掉撰寫分號的麻煩，會在編譯時自動加上分號，但也使得左大括號必須跟著 if 、for、函式定義等語法寫在同一行。
*/

/*
＊＊呼叫函式
函式名稱（參數1,參數2...)

函式（包括 main())可以呼叫其他函式，甚至可以呼叫自己。
一旦出現呼叫動作，就代表控制權從呼叫的一方移交給被呼叫的一方。
等到被呼叫的函式傳回資料、或是來到代表函式結束的右大括號，控制全才會再度轉回先前呼叫函式的一方。
*/

package main

import "fmt"

func main() {
	itemSold()
}

func itemSold() {
	items := make(map[string]int)
	items["Kasa"] = 40
	items["Tasa"] = 130
	items["Raja"] = 60

	for k, v := range items {
		fmt.Printf("%s 賣出 %d 件商品，表現", k, v)
		if v <= 40 {
			fmt.Println("低於預期.")
		} else if v > 40 && v <= 100 {
			fmt.Println("符合預期")
		} else if v > 100 {
			fmt.Println("超乎預期")
		}

	}
}
