//	3-3  數字：整數（integers）、浮點數（floating-point）
//所有數字型別的零值都是 0 。

//  3-3-1  整數 → 有號整數（signed number）、無號整數（unsigned number）
/*
有號整數：可以儲存負值。
無號整數：無法儲存負值。

每種型別可儲存的最大和最小值，都取決於型別的內部儲存容量有幾個位元。

以下是 Go 語言規格中列出的相關整數型別：
uint8	無號 8 位元整數（0~255）
uint16	無號 16 位元整數（0~65535）(0 .. 1<<16-1)
uint32  無號 32 位元整數（0~4294967295）
uint64  無號 64 位元整數（0~18446744073709551615）
int8	有號 8 位元整數（-128~127）
int16	有號 16 位元整數（-32768~32767）
int32	有號 32 位元整數（-2147483648~2147438647）
int64	有號 64 位元整數（-9223372036854775808~9223372036854775807）
byte	uint8的別稱（1 位元組）
rune	uint32的別稱（4 位元組）

以下是特殊的整數型別：
uint	無號 32 、64 位元整數
int		有號 32、64 位元整數
究竟長度是 32 、64 位元，取決於是針對幾位元系統編譯程式。現在大多數是 64 位元。

在 64 位元系統上， int 型別和 int64 的整數範圍就會完全一樣，但 Go 語言將他們視為兩種不同的型別。因為若是 Go 容許兩者混用，這樣對 32 位元機器編譯同一支程式就會發生問題。
在定義變數時，要如何選擇適當的整數型別？
直接用 int 就好，它能完成大部份工作，只有當它造成問題時才考慮其他型別。


在 Go 語言裡布林值就是 true/false ，無法像 C 語言一樣可以用 1/0 代替，只有相同型別的資料可以放在一起運算，不同的話要先做轉換。
*/

// 例、用兩個整數型別建立一個切片集合，後在集合中放進一千萬個數字。最後 GO 程式會用 runtime 套件取得整支程式所使用的堆積記憶體量（位元組），轉換成 MB（百萬位元組）
package main

import (
	"fmt"
	"runtime"
)

func main() {
	var list []int8
	for i := 0; i < 10000000; i++ {
		list = append(list, 100)
	}

	//印出堆積記憶體用量
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	fmt.Printf("TotalAlloc(Heap) = %v MiB\n", m.TotalAlloc/1024/1024)
}

//以上例子可發現，int 改 int8 後，省下了可觀的記憶體，但也只有變數多到一千萬個的程度才有這種明顯效果。
