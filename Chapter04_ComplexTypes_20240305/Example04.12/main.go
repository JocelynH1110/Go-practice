// 4-4-4  了解切片的內部運作

/*
陣列：
是一種資料型別，像是字串 string 或整數 int 一樣。
有型別的資料可以複製，也可以和同型別資料做比較。
但這些資料一經複製，就與原來的資料值沒有關聯了。

切片：
切片和陣列不一樣，他的運作比較像指標，但又不是真的指標。
它底下有個隱藏陣列，用來真正儲存資料。
若對切片加入新的值，這隱藏陣列有可能（但不見得）會被換成更大的陣列。隱藏陣列的管理都是在背景自動進行。

切片的三項隱藏屬性：
1.指向隱藏陣列起始位置的指標。（pointer）
2.長度（length）：切片現有的元素數量。 	//用len()函式查詢長度
3.容量（capacity）：切片可放入的元素總量。	//用cap()函式查詢容量

若用 append() 對切片加入一個值時，取決於切片的容量值，可能會發生的狀況如下：
1.若切片的容量尚有剩餘，意即隱藏陣列還沒滿，那新值就會被放進隱藏陣列，並更新切片的長度值。
2.若切片的容量已滿，Go 語言會產生一個更大的新隱藏陣列、把舊陣列的元素複製過去，並放入新的值。
  接著 Go 語言會更新切片長度值，需要的話也更新切片在陣列的起始位置。

切片也會記住他在原始陣列中的起始位置。若切片和原集合一樣長，其指向的陣列起點就自然是隱藏陣列的第一個元素。


＊＊可以在定義切片時就做初始化、控制長度和容量：（使用內建函式 make() ）
<新切片> = make(<切片型別>, <長度>, [<容量>])

長度參數為必填，容量則為 option （不填時容量即為長度）。
它實際上會建立一個內容全為零值的陣列，並傳回指向這陣列的新切片。
*/

// 練習、用 make() 來控制切片容量
package main

import "fmt"

func genSlices() ([]int, []int, []int) {
	var s1 []int //用 var 建立切片
	s2 := make([]int, 10)
	s3 := make([]int, 10, 50)
	return s1, s2, s3
}
func main() {
	s1, s2, s3 := genSlices()
	fmt.Printf("s1: len = %v cap = %v\n", len(s1), cap(s1))
	fmt.Printf("s2: len = %v cap = %v\n", len(s2), cap(s2))
	fmt.Printf("s3: len = %v cap = %v\n", len(s3), cap(s3))
}

//如果很肯定切片該有多大，通常就需要指定容量，這樣 Go 就不必做額外的隱藏陣列管理，可大大提升運作效能。
