// 4-5  映射表（map）
// 4-5-1  map 的基礎
/*
Go 語言的 map 是一種雜湊表（hashmap）。
和其他兩種集合差別在於索引鍵：
切片和陣列：索引鍵代表位置和計數器，本身無意義，跟資料也無直接的關係。
map：索引鍵本身同時也是資料，與其對應值有真實的關聯。

例如：在 map 裡存一系列使用者帳戶資料，索引鍵是員工編號，這本身也是資料，不只代表資料位置而已。用員工編號就可以調出相關帳戶資料，不必逐一走訪整個陣列或切片。有了 map 就可快速建立、取得、刪除集合中的資料。

取得 map 中的元素，和存取陣列和切片類似：使用[]。
任何可以用來做比較的資料型態，都可以當作 map 索引鍵型別，整數或字串都可以。但切片不行，因為切片不能被比較。
map 的資料值則可以是任何型別，包括 pointer、slice、另一個 map 。

不應該用 map 來儲存有序資料。即便用 int 整數型別當 map 的索引鍵，也不保證走訪整個 map 時資料會照索引鍵大小排序。
Go 語言在你用 for range 時會故意打亂元素順序（不是隨機而是非決定性的），好確保沒人會走撇步、只靠元素的次序取值。
故若真要以特定順序走訪資料，還是改用陣列或切片。
*/

/*
＊＊map 的定義語法：
map[<鍵型別>]<值型別>

＊＊Go 語言不會初始化 map 的鍵與值（map 的零值是 nil），在定義 map 時一併賦予索引鍵和值：
map[<鍵型別>]<值型別>{<鍵1>:<值1>,<鍵2>:<值2>,...<鍵N>:<值N>}
//若你嘗試對一個未經初始化的 map 賦值，就會引發執行期間 panic（lesson 6），所以盡量避免定義一個零值 map 。

＊＊（更常用的方式）用 make() 函式傳回一個經過初始化的 map ，但 make() 在此傳入的參數會和初始化切片時有所不同：
make(map[<鍵型別>]<值型別>,<容量>)

Go 語言不會替 map 建立索引鍵，所以無法像切片那樣在 make() 給它指定的特定長度。
容量：是選擇性的，可以設置更大的空間，但無法用 cap() 函式來查詢 map 容量。

複製：和切片一樣，若將一個 map 複製給另一個 map ，底下實際上會指向一樣的資料（有連結性）。若要複製但避免這種連結性，就得用迴圈走訪其中一個 map 、然後將鍵與值寫入另一個 map 。

＊＊初始完畢後，用中括號[]對 map 加入元素（鍵與值），且不必像在處理陣列和切片時擔心其長度問題：
<map名稱>[<索引鍵>] = <值>
*/

// 練習、建立、讀取、寫入一個 map
package main

import "fmt"

func getUsers() map[string]string {
	users := map[string]string{
		"305": "Susan",
		"408": "Tidi",
		"604": "Gigi",
	}
	users["809"] = "Rusa"
	return users
}

func main() {
	fmt.Println("Users:", getUsers())
}

//使用 map 的時機，取決於你要在其中儲存何種資料，以及是否需要取用各別資料（而非一系列資料的清單）。
